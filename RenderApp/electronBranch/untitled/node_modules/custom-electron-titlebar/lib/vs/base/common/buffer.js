"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newWriteableBufferStream = exports.streamToBufferReadableStream = exports.bufferToStream = exports.bufferedStreamToBuffer = exports.streamToBuffer = exports.bufferToReadable = exports.readableToBuffer = exports.writeUInt8 = exports.readUInt8 = exports.writeUInt32LE = exports.readUInt32LE = exports.writeUInt32BE = exports.readUInt32BE = exports.writeUInt16LE = exports.readUInt16LE = exports.VSBuffer = void 0;

const strings = require("./strings");

const streams = require("./stream");

const hasBuffer = typeof Buffer !== 'undefined';
const hasTextEncoder = typeof TextEncoder !== 'undefined';
const hasTextDecoder = typeof TextDecoder !== 'undefined';
let textEncoder;
let textDecoder;

class VSBuffer {
  constructor(buffer) {
    this.buffer = buffer;
    this.byteLength = this.buffer.byteLength;
  }

  static alloc(byteLength) {
    if (hasBuffer) {
      return new VSBuffer(Buffer.allocUnsafe(byteLength));
    } else {
      return new VSBuffer(new Uint8Array(byteLength));
    }
  }

  static wrap(actual) {
    if (hasBuffer && !Buffer.isBuffer(actual)) {
      // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
      // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array
      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
    }

    return new VSBuffer(actual);
  }

  static fromString(source) {
    if (hasBuffer) {
      return new VSBuffer(Buffer.from(source));
    } else if (hasTextEncoder) {
      if (!textEncoder) {
        textEncoder = new TextEncoder();
      }

      return new VSBuffer(textEncoder.encode(source));
    } else {
      return new VSBuffer(strings.encodeUTF8(source));
    }
  }

  static concat(buffers, totalLength) {
    if (typeof totalLength === 'undefined') {
      totalLength = 0;

      for (let i = 0, len = buffers.length; i < len; i++) {
        totalLength += buffers[i].byteLength;
      }
    }

    const ret = VSBuffer.alloc(totalLength);
    let offset = 0;

    for (let i = 0, len = buffers.length; i < len; i++) {
      const element = buffers[i];
      ret.set(element, offset);
      offset += element.byteLength;
    }

    return ret;
  }

  toString() {
    if (hasBuffer) {
      return this.buffer.toString();
    } else if (hasTextDecoder) {
      if (!textDecoder) {
        textDecoder = new TextDecoder();
      }

      return textDecoder.decode(this.buffer);
    } else {
      return strings.decodeUTF8(this.buffer);
    }
  }

  slice(start, end) {
    // IMPORTANT: use subarray instead of slice because TypedArray#slice
    // creates shallow copy and NodeBuffer#slice doesn't. The use of subarray
    // ensures the same, performant, behaviour.
    return new VSBuffer(this.buffer.subarray(start
    /*bad lib.d.ts*/
    , end));
  }

  set(array, offset) {
    if (array instanceof VSBuffer) {
      this.buffer.set(array.buffer, offset);
    } else {
      this.buffer.set(array, offset);
    }
  }

  readUInt32BE(offset) {
    return readUInt32BE(this.buffer, offset);
  }

  writeUInt32BE(value, offset) {
    writeUInt32BE(this.buffer, value, offset);
  }

  readUInt32LE(offset) {
    return readUInt32LE(this.buffer, offset);
  }

  writeUInt32LE(value, offset) {
    writeUInt32LE(this.buffer, value, offset);
  }

  readUInt8(offset) {
    return readUInt8(this.buffer, offset);
  }

  writeUInt8(value, offset) {
    writeUInt8(this.buffer, value, offset);
  }

}

exports.VSBuffer = VSBuffer;

function readUInt16LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}

exports.readUInt16LE = readUInt16LE;

function writeUInt16LE(destination, value, offset) {
  destination[offset + 0] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 1] = value & 0b11111111;
}

exports.writeUInt16LE = writeUInt16LE;

function readUInt32BE(source, offset) {
  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];
}

exports.readUInt32BE = readUInt32BE;

function writeUInt32BE(destination, value, offset) {
  destination[offset + 3] = value;
  value = value >>> 8;
  destination[offset + 2] = value;
  value = value >>> 8;
  destination[offset + 1] = value;
  value = value >>> 8;
  destination[offset] = value;
}

exports.writeUInt32BE = writeUInt32BE;

function readUInt32LE(source, offset) {
  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0 | source[offset + 2] << 16 >>> 0 | source[offset + 3] << 24 >>> 0;
}

exports.readUInt32LE = readUInt32LE;

function writeUInt32LE(destination, value, offset) {
  destination[offset + 0] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 1] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 2] = value & 0b11111111;
  value = value >>> 8;
  destination[offset + 3] = value & 0b11111111;
}

exports.writeUInt32LE = writeUInt32LE;

function readUInt8(source, offset) {
  return source[offset];
}

exports.readUInt8 = readUInt8;

function writeUInt8(destination, value, offset) {
  destination[offset] = value;
}

exports.writeUInt8 = writeUInt8;

function readableToBuffer(readable) {
  return streams.consumeReadable(readable, chunks => VSBuffer.concat(chunks));
}

exports.readableToBuffer = readableToBuffer;

function bufferToReadable(buffer) {
  return streams.toReadable(buffer);
}

exports.bufferToReadable = bufferToReadable;

function streamToBuffer(stream) {
  return streams.consumeStream(stream, chunks => VSBuffer.concat(chunks));
}

exports.streamToBuffer = streamToBuffer;

async function bufferedStreamToBuffer(bufferedStream) {
  if (bufferedStream.ended) {
    return VSBuffer.concat(bufferedStream.buffer);
  }

  return VSBuffer.concat([// Include already read chunks...
  ...bufferedStream.buffer, // ...and all additional chunks
  await streamToBuffer(bufferedStream.stream)]);
}

exports.bufferedStreamToBuffer = bufferedStreamToBuffer;

function bufferToStream(buffer) {
  return streams.toStream(buffer, chunks => VSBuffer.concat(chunks));
}

exports.bufferToStream = bufferToStream;

function streamToBufferReadableStream(stream) {
  return streams.transform(stream, {
    data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data)
  }, chunks => VSBuffer.concat(chunks));
}

exports.streamToBufferReadableStream = streamToBufferReadableStream;

function newWriteableBufferStream(options) {
  return streams.newWriteableStream(chunks => VSBuffer.concat(chunks), options);
}

exports.newWriteableBufferStream = newWriteableBufferStream;